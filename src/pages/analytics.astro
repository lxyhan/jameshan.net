---
import IndexLayout from '@/layouts/IndexLayout.astro'
import { themeConfig } from '@/config'
---

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

<IndexLayout
  title={`Analytics Â· ${themeConfig.site.title}`}
  description="Site analytics and statistics"
  hideHeader={true}
>
  <div class="analytics-page">
    <h1>Analytics</h1>

    <p class="methodology">Page views are recorded to a Supabase Postgres database on each request. Bot traffic is identified using user-agent pattern matching and excluded from counts. To prevent artificial inflation from page refreshes or rapid navigation, views from the same IP address to the same page within a 2.5-minute window are deduplicated at query time. IP addresses are stored as SHA-256 hashes, not in plaintext. No cookies are used, no fingerprinting, no third-party scripts. The raw view data is queried client-side and aggregated in the browser.</p>

    <div class="stats-row">
      <div class="stat">
        <span class="stat-value" id="today-views"></span>
        <span class="stat-label">views today</span>
      </div>
      <div class="stat">
        <span class="stat-value" id="all-views"></span>
        <span class="stat-label">views all time</span>
      </div>
    </div>

    <div class="histogram-section">
      <div class="histogram-header">
        <h2>Last <select id="days-select">
          <option value="7">7</option>
          <option value="30">30</option>
          <option value="60" selected>60</option>
        </select> days</h2>
      </div>
      <div class="histogram-container">
        <div class="y-axis" id="y-axis">
          <span id="y-max"></span>
          <span id="y-mid"></span>
          <span id="y-min">0</span>
        </div>
        <div class="histogram" id="histogram">
                  </div>
        <div class="tooltip" id="tooltip"></div>
      </div>
      <div class="histogram-labels">
        <span id="start-date">...</span>
        <span id="end-date">...</span>
      </div>
    </div>

    <div class="locations-section">
      <h2>Views by country (all time)</h2>
      <div class="locations-grid">
        <div class="map-container" id="map-container"></div>
        <div class="locations-list" id="locations-list">
          <span class="loading-text">Loading...</span>
        </div>
      </div>
    </div>
  </div>
</IndexLayout>

<script>
  const STATS_CACHE_KEY = 'analytics_stats_cache';

  function showStats(data: any) {
    const todayEl = document.getElementById('today-views');
    const allEl = document.getElementById('all-views');
    if (todayEl && data?.humanToday !== undefined) {
      todayEl.textContent = data.humanToday?.toLocaleString() || '0';
      todayEl.classList.add('loaded');
    }
    if (allEl && data?.humanAllTime !== undefined) {
      allEl.textContent = data.humanAllTime?.toLocaleString() || '0';
      allEl.classList.add('loaded');
    }
  }

  async function loadStats() {
    // Show cached data immediately
    const cached = localStorage.getItem(STATS_CACHE_KEY);
    if (cached) {
      try {
        showStats(JSON.parse(cached));
      } catch { /* ignore parse errors */ }
    }

    // Fetch fresh data
    try {
      const response = await fetch('/api/analytics');
      if (response.ok) {
        const data = await response.json();
        localStorage.setItem(STATS_CACHE_KEY, JSON.stringify(data));
        showStats(data);
      }
    } catch (error) {
      console.debug('Failed to load stats:', error);
    }
  }

  function getHistogramCacheKey(days: number) {
    return `analytics_histogram_${days}`;
  }

  function showHistogram(data: any) {
    const container = document.getElementById('histogram');
    const startLabel = document.getElementById('start-date');
    const endLabel = document.getElementById('end-date');
    const tooltip = document.getElementById('tooltip');

    if (container && data?.days && data.days.length > 0) {
      const maxViews = Math.max(...data.days.map((d: any) => d.views), 1);

      container.innerHTML = data.days.map((day: any) => {
        const height = Math.max((day.views / maxViews) * 100, 2);
        return `<div class="bar" style="height: ${height}%" data-date="${day.date}" data-views="${day.views}"></div>`;
      }).join('');

      container.classList.add('loaded');

      // Update y-axis labels
      const yMax = document.getElementById('y-max');
      const yMid = document.getElementById('y-mid');
      if (yMax) yMax.textContent = maxViews.toString();
      if (yMid) yMid.textContent = Math.round(maxViews / 2).toString();

      // Add hover listeners
      container.querySelectorAll('.bar').forEach(bar => {
        bar.addEventListener('mouseenter', (e) => {
          const target = e.target as HTMLElement;
          const date = new Date(target.dataset.date + 'T00:00:00');
          const formatted = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
          const views = target.dataset.views;
          if (tooltip) {
            tooltip.textContent = `${formatted}: ${views} views`;
            tooltip.style.opacity = '1';
          }
        });
        bar.addEventListener('mouseleave', () => {
          if (tooltip) tooltip.style.opacity = '0';
        });
      });

      if (startLabel && data.days[0]) {
        const d = new Date(data.days[0].date + 'T00:00:00');
        startLabel.textContent = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      }
      if (endLabel && data.days[data.days.length - 1]) {
        const d = new Date(data.days[data.days.length - 1].date + 'T00:00:00');
        endLabel.textContent = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      }
    }
  }

  async function loadHistogram(days = 60) {
    const cacheKey = getHistogramCacheKey(days);

    // Show cached data immediately
    const cached = localStorage.getItem(cacheKey);
    if (cached) {
      try {
        showHistogram(JSON.parse(cached));
      } catch { /* ignore parse errors */ }
    }

    // Fetch fresh data
    try {
      const response = await fetch(`/api/analytics/daily?days=${days}`);
      if (response.ok) {
        const data = await response.json();
        localStorage.setItem(cacheKey, JSON.stringify(data));
        showHistogram(data);
      }
    } catch (error) {
      console.debug('Failed to load histogram:', error);
    }
  }

  // Dropdown handler
  const daysSelect = document.getElementById('days-select') as HTMLSelectElement;
  if (daysSelect) {
    daysSelect.addEventListener('change', () => {
      loadHistogram(parseInt(daysSelect.value, 10));
    });
  }

  // Country code to name mapping
  const countryNames: Record<string, string> = {
    US: 'United States', CA: 'Canada', GB: 'United Kingdom', DE: 'Germany',
    FR: 'France', JP: 'Japan', AU: 'Australia', CN: 'China', IN: 'India',
    BR: 'Brazil', MX: 'Mexico', KR: 'South Korea', IT: 'Italy', ES: 'Spain',
    NL: 'Netherlands', SE: 'Sweden', NO: 'Norway', DK: 'Denmark', FI: 'Finland',
    PL: 'Poland', RU: 'Russia', UA: 'Ukraine', SG: 'Singapore', HK: 'Hong Kong',
    TW: 'Taiwan', NZ: 'New Zealand', IE: 'Ireland', CH: 'Switzerland', AT: 'Austria',
    BE: 'Belgium', PT: 'Portugal', CZ: 'Czech Republic', RO: 'Romania', HU: 'Hungary',
    GR: 'Greece', IL: 'Israel', AE: 'UAE', SA: 'Saudi Arabia', ZA: 'South Africa',
    AR: 'Argentina', CL: 'Chile', CO: 'Colombia', PH: 'Philippines', MY: 'Malaysia',
    TH: 'Thailand', VN: 'Vietnam', ID: 'Indonesia', PK: 'Pakistan', BD: 'Bangladesh',
    EG: 'Egypt', NG: 'Nigeria', KE: 'Kenya', TR: 'Turkey',
  };

  // ISO Alpha-3 to Alpha-2 mapping for GeoJSON
  const iso3to2: Record<string, string> = {
    AFG: 'AF', ALB: 'AL', DZA: 'DZ', AGO: 'AO', ARG: 'AR', ARM: 'AM', AUS: 'AU', AUT: 'AT',
    AZE: 'AZ', BHS: 'BS', BGD: 'BD', BLR: 'BY', BEL: 'BE', BLZ: 'BZ', BEN: 'BJ', BTN: 'BT',
    BOL: 'BO', BIH: 'BA', BWA: 'BW', BRA: 'BR', BRN: 'BN', BGR: 'BG', BFA: 'BF', BDI: 'BI',
    KHM: 'KH', CMR: 'CM', CAN: 'CA', CAF: 'CF', TCD: 'TD', CHL: 'CL', CHN: 'CN', COL: 'CO',
    COG: 'CG', COD: 'CD', CRI: 'CR', HRV: 'HR', CUB: 'CU', CYP: 'CY', CZE: 'CZ', DNK: 'DK',
    DOM: 'DO', ECU: 'EC', EGY: 'EG', SLV: 'SV', GNQ: 'GQ', ERI: 'ER', EST: 'EE', ETH: 'ET',
    FIN: 'FI', FRA: 'FR', GAB: 'GA', GMB: 'GM', GEO: 'GE', DEU: 'DE', GHA: 'GH', GRC: 'GR',
    GTM: 'GT', GIN: 'GN', GNB: 'GW', GUY: 'GY', HTI: 'HT', HND: 'HN', HKG: 'HK', HUN: 'HU',
    ISL: 'IS', IND: 'IN', IDN: 'ID', IRN: 'IR', IRQ: 'IQ', IRL: 'IE', ISR: 'IL', ITA: 'IT',
    JAM: 'JM', JPN: 'JP', JOR: 'JO', KAZ: 'KZ', KEN: 'KE', PRK: 'KP', KOR: 'KR', KWT: 'KW',
    KGZ: 'KG', LAO: 'LA', LVA: 'LV', LBN: 'LB', LSO: 'LS', LBR: 'LR', LBY: 'LY', LTU: 'LT',
    LUX: 'LU', MKD: 'MK', MDG: 'MG', MWI: 'MW', MYS: 'MY', MLI: 'ML', MRT: 'MR', MEX: 'MX',
    MDA: 'MD', MNG: 'MN', MNE: 'ME', MAR: 'MA', MOZ: 'MZ', MMR: 'MM', NAM: 'NA', NPL: 'NP',
    NLD: 'NL', NZL: 'NZ', NIC: 'NI', NER: 'NE', NGA: 'NG', NOR: 'NO', OMN: 'OM', PAK: 'PK',
    PAN: 'PA', PNG: 'PG', PRY: 'PY', PER: 'PE', PHL: 'PH', POL: 'PL', PRT: 'PT', PRI: 'PR',
    QAT: 'QA', ROU: 'RO', RUS: 'RU', RWA: 'RW', SAU: 'SA', SEN: 'SN', SRB: 'RS', SLE: 'SL',
    SGP: 'SG', SVK: 'SK', SVN: 'SI', SOM: 'SO', ZAF: 'ZA', SSD: 'SS', ESP: 'ES', LKA: 'LK',
    SDN: 'SD', SUR: 'SR', SWZ: 'SZ', SWE: 'SE', CHE: 'CH', SYR: 'SY', TWN: 'TW', TJK: 'TJ',
    TZA: 'TZ', THA: 'TH', TGO: 'TG', TTO: 'TT', TUN: 'TN', TUR: 'TR', TKM: 'TM', UGA: 'UG',
    UKR: 'UA', ARE: 'AE', GBR: 'GB', USA: 'US', URY: 'UY', UZB: 'UZ', VEN: 'VE', VNM: 'VN',
    YEM: 'YE', ZMB: 'ZM', ZWE: 'ZW',
  };

  let mapInstance: any = null;

  async function loadMap(data: { countries: Record<string, number>, total: number }) {
    const mapContainer = document.getElementById('map-container');
    if (!mapContainer) return;

    // Dynamically import Leaflet
    const leaflet = await import('leaflet');
    const L = leaflet.default || leaflet;

    // Clean up existing map
    if (mapInstance) {
      mapInstance.remove();
    }

    try {
      // Fetch GeoJSON
      const geoResponse = await fetch('/countries.geo.json');
      const geoData = await geoResponse.json();

      const entries = Object.entries(data.countries);
      const maxCount = Math.max(...entries.map(([, c]) => c), 1);

      // Get color based on count
      function getColor(count: number): string {
        if (!count) return 'var(--border)';
        const intensity = Math.min(count / maxCount, 1);
        // Use a blue scale
        const lightness = 80 - (intensity * 45);
        return `hsl(210, 50%, ${lightness}%)`;
      }

      // Create map
      mapInstance = L.map(mapContainer, {
        zoomControl: false,
        attributionControl: false,
        dragging: false,
        scrollWheelZoom: false,
        doubleClickZoom: false,
        touchZoom: false,
      }).fitWorld().setView([35, 0], 1);

      // Style function
      function style(feature: any) {
        const iso3 = feature.id;
        const iso2 = iso3to2[iso3] || iso3;
        const count = data.countries[iso2] || 0;
        return {
          fillColor: getColor(count),
          weight: 0.5,
          opacity: 1,
          color: 'var(--bg)',
          fillOpacity: 0.9,
        };
      }

      // Hover handlers
      function onEachFeature(feature: any, layer: any) {
        const iso3 = feature.id;
        const iso2 = iso3to2[iso3] || iso3;
        const count = data.countries[iso2] || 0;
        const name = feature.properties.name;

        if (count > 0) {
          layer.bindTooltip(`${name}: ${count} views`, {
            sticky: true,
            className: 'map-tooltip-leaflet',
          });
        }

        layer.on({
          mouseover: (e: any) => {
            if (count > 0) {
              e.target.setStyle({ fillOpacity: 0.7 });
            }
          },
          mouseout: (e: any) => {
            if (count > 0) {
              e.target.setStyle({ fillOpacity: 0.9 });
            }
          },
        });
      }

      L.geoJSON(geoData, { style, onEachFeature }).addTo(mapInstance);
      mapContainer.classList.add('loaded');
    } catch (error) {
      console.debug('Failed to load map:', error);
    }
  }

  function showLocations(data: { countries: Record<string, number>, total: number }) {
    const container = document.getElementById('locations-list');
    if (!container) return;

    // Also update the map
    loadMap(data);

    const entries = Object.entries(data.countries);
    if (entries.length === 0) {
      container.innerHTML = '<span class="no-data">No location data yet</span>';
      return;
    }

    container.innerHTML = entries
      .slice(0, 15) // Show top 15 countries
      .map(([code, count]) => {
        const name = countryNames[code] || code;
        const percent = ((count / data.total) * 100).toFixed(1);
        return `<div class="location-item">
          <span class="country-name">${name}</span>
          <span class="country-count">${count} (${percent}%)</span>
        </div>`;
      })
      .join('');

    container.classList.add('loaded');
  }

  async function loadLocations() {
    const cacheKey = 'analytics_locations_cache';

    // Show cached data immediately
    const cached = localStorage.getItem(cacheKey);
    if (cached) {
      try {
        showLocations(JSON.parse(cached));
      } catch { /* ignore parse errors */ }
    }

    // Fetch fresh data
    try {
      const response = await fetch('/api/analytics/locations');
      if (response.ok) {
        const data = await response.json();
        localStorage.setItem(cacheKey, JSON.stringify(data));
        showLocations(data);
      }
    } catch (error) {
      console.debug('Failed to load locations:', error);
    }
  }

  loadStats();
  loadHistogram(60);
  loadLocations();

  document.addEventListener('astro:page-load', () => {
    loadStats();
    loadHistogram();
    loadLocations();
  });
</script>

<style is:global>
  .analytics-page {
    max-width: 100%;
  }

  h1 {
    font-size: 1rem;
    margin-bottom: 1rem;
    font-weight: var(--font-weight-bold);
  }

  h2 {
    font-size: 0.85rem;
    margin-bottom: 0.5rem;
    color: var(--text-secondary);
    font-weight: normal;
  }

  .stats-row {
    display: flex;
    gap: 2rem;
    margin-bottom: 2rem;
  }

  .stat {
    display: flex;
    flex-direction: column;
  }

  .stat-value {
    font-size: 1.5rem;
    font-weight: var(--font-weight-bold);
    line-height: 1.2;
  }

  .stat-label {
    font-size: 0.8rem;
    color: var(--text-secondary);
  }

  .methodology {
    font-size: 0.8rem;
    color: var(--text-secondary);
    margin-bottom: 1.5rem;
    line-height: 1.5;
  }

  .methodology a {
    color: var(--text-secondary);
    text-decoration: underline;
  }

  .histogram-section {
    margin-top: 1.5rem;
  }

  .histogram-header {
    display: flex;
    align-items: center;
  }

  .histogram-header h2 {
    display: flex;
    align-items: center;
    gap: 0.25rem;
  }

  #days-select {
    font-size: 0.85rem;
    font-family: inherit;
    background: transparent;
    border: none;
    border-bottom: 1px solid var(--text-secondary);
    color: var(--text-primary);
    cursor: pointer;
    padding: 0 0.25rem;
  }

  #days-select:focus {
    outline: none;
    border-bottom-color: var(--text-primary);
  }

  .histogram-container {
    position: relative;
    display: flex;
    gap: 0.5rem;
  }

  .y-axis {
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: flex-end;
    height: 120px;
    padding: 0.5rem 0;
    font-size: 0.65rem;
    color: var(--text-secondary);
    min-width: 24px;
  }

  .histogram {
    display: flex;
    align-items: flex-end;
    gap: 2px;
    height: 120px;
    padding: 0.5rem 0;
    flex: 1;
  }

  .tooltip {
    position: absolute;
    top: 0;
    right: 0;
    font-size: 0.75rem;
    color: var(--text-secondary);
    opacity: 0;
    transition: opacity 0.15s;
    pointer-events: none;
  }

  .bar {
    flex: 1;
    background: var(--text-primary);
    min-width: 2px;
    transition: opacity 0.15s;
    cursor: pointer;
  }

  .bar:hover {
    opacity: 0.7;
  }

  .histogram-labels {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    color: var(--text-secondary);
    margin-top: 0.25rem;
  }

  .stat-value {
    opacity: 0;
    transition: opacity 0.3s ease;
    display: inline-block;
    min-width: 45px;
    min-height: 1.8rem;
  }

  .stat-value.loaded {
    opacity: 1;
  }

  .histogram {
    opacity: 0;
    transition: opacity 0.4s ease;
  }

  .histogram.loaded {
    opacity: 1;
  }

  @media (max-width: 768px) {
    .histogram {
      height: 80px;
    }
    .y-axis {
      height: 80px;
    }
  }

  .locations-section {
    margin-top: 2rem;
  }

  .locations-grid {
    display: grid;
    grid-template-columns: 1fr 200px;
    gap: 1.5rem;
    align-items: start;
  }

  .map-container {
    position: relative;
    width: 100%;
    height: 380px;
    opacity: 0;
    transition: opacity 0.3s ease;
    background: var(--bg-secondary);
    border-radius: 4px;
    overflow: hidden;
  }

  .map-container.loaded {
    opacity: 1;
  }

  /* Leaflet map overrides */
  .map-container .leaflet-container {
    background: var(--bg-secondary);
    height: 100%;
    width: 100%;
  }

  .map-tooltip-leaflet {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 2px;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    color: var(--text-secondary);
    box-shadow: none;
  }

  .map-tooltip-leaflet::before {
    display: none;
  }

  @media (max-width: 768px) {
    .locations-grid {
      grid-template-columns: 1fr;
    }
    .map-container {
      height: 200px;
    }
  }

  .locations-list {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .locations-list.loaded {
    opacity: 1;
  }

  .loading-text, .no-data {
    font-size: 0.8rem;
    color: var(--text-secondary);
  }

  .location-item {
    display: flex;
    justify-content: space-between;
    font-size: 0.85rem;
    padding: 0.25rem 0;
    border-bottom: 1px solid var(--border);
  }

  .location-item:last-child {
    border-bottom: none;
  }

  .country-name {
    color: var(--text-primary);
  }

  .country-count {
    color: var(--text-secondary);
    font-size: 0.8rem;
  }
</style>
